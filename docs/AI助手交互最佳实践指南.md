# AI助手交互最佳实践指南

## 1. 代码分析技巧

### 1.1 渐进式分析
```markdown
- 从目录结构开始，逐层深入分析
- 先了解整体架构，再深入具体实现
- 使用递归目录列表查看完整项目结构

示例：
```typescript
// 1. 先查看顶层目录结构
<list_files>
<path>.</path>
<recursive>false</recursive>
</list_files>

// 2. 深入查看关键目录
<list_files>
<path>src</path>
<recursive>true</recursive>
</list_files>

// 3. 当目录内容较多时，使用分块获取
<list_files>
<path>src</path>
<recursive>true</recursive>
<block>2</block>
</list_files>
```
```

### 1.2 分析顺序
```markdown
1. 查看项目结构（使用list_files工具）
2. 识别关键文件（如hooks、组件、配置文件）
3. 阅读核心文件内容（使用read_file工具）
4. 总结实现逻辑

实际案例：
1. 分析项目结构：
   - 识别出src/hooks/useTurbine.ts为核心业务逻辑
   - 发现src/components中包含多个监测面板组件
   
2. 深入核心文件：
   ```typescript
   <read_file>
   <path>src/hooks/useTurbine.ts</path>
   </read_file>
   ```

3. 总结实现逻辑：
   - 3D模型加载与渲染
   - 监测功能实现
   - 可视化效果
   - 核心流程
```

### 1.3 分析思路
```markdown
- 寻找关键目录（如src/api, src/hooks, src/components）
- 识别业务逻辑的组织方式（API层、状态管理、组件设计）
- 理解数据流向和状态管理方式

分析步骤示例：
1. 检查是否有专门的API层
   ```typescript
   <list_files>
   <path>src/api</path>
   <recursive>false</recursive>
   </list_files>
   ```

2. 查找状态管理实现
   ```typescript
   <list_files>
   <path>src/stores</path>
   <recursive>false</recursive>
   </list_files>
   ```

3. 分析替代方案
   - 检查hooks中的业务逻辑
   - 查看组件内的状态管理
   - 寻找其他状态共享方式
```

## 2. 有效沟通模式

### 2.1 问题分解
```markdown
- 将复杂问题拆分为小步骤
- 每次聚焦于一个具体方面
- 循序渐进地构建理解

示例：分析运行监测系统
1. 第一步：了解项目结构
2. 第二步：分析核心业务逻辑（useTurbine.ts）
3. 第三步：查看数据可视化实现（useEcharts.ts）
4. 第四步：研究组件设计（WidgetPanel*.vue）
```

### 2.2 信息反馈
```markdown
- 每次分析后提供清晰的思考过程
- 使用<thinking>标签展示分析思路
- 在需要时请求更多信息或确认

示例：
<thinking>
从完整的目录结构来看，运行监测相关的逻辑可能分布在以下几个地方：

1. src/hooks/useTurbine.ts - 可能包含风机监测的核心逻辑
2. src/components/WidgetPanel*.vue - 可能包含监测数据的可视化组件
3. src/hooks/useEcharts.ts - 可能包含监测数据的图表展示逻辑
4. src/layout/LayoutPanel.vue - 可能包含监测面板的布局
</thinking>
```

### 2.3 结构化输出
```markdown
- 使用Markdown格式组织信息
- 采用层级结构展示内容
- 突出重点，使用列表和标题

示例：
## 运行监测部分实现逻辑总结

### 1. 3D模型监测系统
- **核心文件**: useTurbine.ts
- **功能**:
  - 加载风机3D模型和设备骨架
  - 实现设备分解/组合动画
  - 设备状态监测(告警模拟、部件交互)
```

## 3. 技术文档编写

### 3.1 文档结构
```markdown
- 清晰的标题层级
- 逻辑性强的内容组织
- 重点内容突出显示

文档结构示例：
# 项目名称
## 1. 项目概述
## 2. 技术架构
## 3. 核心功能
### 3.1 功能A
### 3.2 功能B
## 4. 实现细节
## 5. 注意事项
```

### 3.2 内容要素
```markdown
- 核心功能说明
- 实现逻辑描述
- 关键技术点解释
- 扩展性考虑

示例：
### 核心功能：运行监测系统
1. 3D模型监测
   - 实时状态展示
   - 告警模拟
   - 交互操作

2. 数据可视化
   - 多种图表类型
   - 实时数据更新
   - 响应式布局
```

### 3.3 示例展示
```markdown
- 使用代码片段说明
- 提供具体使用场景
- 包含注意事项说明

示例：
```typescript
// 使用useTurbine hook实现设备监测
const { startWarning, stopWarning } = useTurbine()

// 告警模拟
startWarning() // 开始告警
setTimeout(() => {
  stopWarning() // 5秒后停止告警
}, 5000)
```
```

## 4. 协作开发技巧

### 4.1 需求理解
```markdown
- 主动询问不明确的点
- 确认关键需求和约束
- 提供可行的实现方案

示例：
<ask_followup_question>
<question>您提到的运行监测，是否需要包含实时数据更新功能？这将影响到我们是否需要实现WebSocket连接或轮询机制。</question>
</ask_followup_question>
```

### 4.2 代码审查
```markdown
- 关注代码组织方式
- 分析实现逻辑
- 提供优化建议

代码审查要点：
1. 架构设计
   - 目录结构合理性
   - 代码分层是否清晰
   
2. 实现细节
   - 核心逻辑是否清晰
   - 是否有重复代码
   
3. 可维护性
   - 代码注释是否充分
   - 是否遵循最佳实践
```

### 4.3 问题解决
```markdown
- 系统性分析问题
- 提供可执行的解决方案
- 说明潜在的影响

问题解决流程：
1. 问题定位
   - 收集错误信息
   - 复现问题场景
   
2. 方案制定
   - 提出可能的解决方案
   - 评估方案可行性
   
3. 实施与验证
   - 实施选定方案
   - 验证问题是否解决
```

## 5. 最佳实践总结

### 5.1 交互原则
```markdown
1. 保持对话焦点明确
2. 循序渐进地展开分析
3. 及时提供反馈和确认

实践要点：
- 每次只关注一个主题
- 在转换话题前总结当前进展
- 主动确认理解是否正确
```

### 5.2 文档维护
```markdown
1. 及时更新文档内容
2. 保持文档结构清晰
3. 突出重要信息

文档维护检查清单：
- [ ] 文档结构是否清晰
- [ ] 重要信息是否突出
- [ ] 示例是否具体
- [ ] 格式是否统一
```

### 5.3 协作效率
```markdown
1. 明确沟通目标
2. 采用结构化的分析方法
3. 保持交互的连贯性

效率提升技巧：
1. 使用工具前的准备
   - 确认工具的功能和限制
   - 准备必要的参数
   
2. 结果的处理
   - 及时分析工具返回的结果
   - 根据结果调整下一步计划
   
3. 异常处理
   - 预判可能的异常情况
   - 准备备选方案
```

## 6. 错误处理和异常情况

### 6.1 常见错误类型
```markdown
1. 工具使用错误
   - 参数格式不正确
   - 路径不存在
   - 权限不足

2. 业务逻辑错误
   - 数据格式不匹配
   - 状态更新失败
   - 组件通信异常
```

### 6.2 处理策略
```markdown
1. 预防措施
   - 使用工具前验证参数
   - 检查文件/目录是否存在
   - 确认操作权限

2. 错误恢复
   - 提供清晰的错误信息
   - 建议可能的解决方案
   - 回滚到上一个正确状态
```

### 6.3 最佳实践
```markdown
1. 错误处理流程
   - 识别错误类型
   - 定位错误原因
   - 实施解决方案
   - 验证修复结果

2. 文档记录
   - 记录错误场景
   - 记录解决方案
   - 更新最佳实践
```